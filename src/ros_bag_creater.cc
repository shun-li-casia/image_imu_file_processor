/*******************************************************************************
 *   Copyright (C) 2023 CASIA. All rights reserved.
 *
 *   @Filename: offline_stereo_rectify.cc
 *
 *   @Author: shun li
 *
 *   @Email: shun.li.at.casia@outlook.com
 *
 *   @Date: 09/10/2023
 *
 *   @Description:
 *
 *******************************************************************************/

#include "utility_tool/cmdline.h"
#include "utility_tool/system_lib.h"
#include "utility_tool/print_ctrl_macro.h"
#include "utility_tool/pcm_debug_helper.h"
#include "image_imu_file_processor/img_imu_align.h"
#include "image_imu_file_processor/img_file_name_checker.h"
#include "sensor_config/modules/stereo_rectifier.h"

#include <ros/ros.h>
#include <rosbag/bag.h>
#include <rosbag/view.h>
#include <sensor_msgs/Imu.h>
#include <sensor_msgs/Image.h>
#include <cv_bridge/cv_bridge.h>

#include <Eigen/Core>

ros::Time Tp2RosT(uint64_t tp) {
  std::string buf = std::to_string(tp);
  std::string s_sec = buf.substr(0, 10), s_mui_sec = buf.substr(10, 6);
  uint32_t sec = std::atoll(s_sec.c_str());
  uint32_t mui_sec = std::atoll(s_mui_sec.c_str());
  return ros::Time(sec, mui_sec * 1e3);
}

int main(int argc, char** argv) {
  cmdline::parser par;
  par.add<std::string>(
      "imu_path", 0,
      "the imu and raw stereo calibration file, generated by kalibr", true);

  par.add<std::string>("img_paths", 0,
                       "the image bin file path, which should be "
                       "cam_ch_00.bin,cam_ch_01.bin,... they will be taken as "
                       "{cam_ch_00,cam_ch_01}, {cam_ch_02, cam_ch_03}...",
                       true);
  par.add<std::string>("rosbag_name", 0, "created ros bag name", true);

  par.add<int>("img_step", 0, "steps to jump over some imags", false, 1);

  par.add<int>("img_num", 0, "total number of images", false, INT_MAX);

  par.parse_check(argc, argv);

  // imu path
  const std::string imu_path = par.get<std::string>("imu_path");
  // imu reader...
  ImuReader imu_reader(imu_path);
  if (!imu_reader.OpenFile()) {
    PCM_PRINT_ERROR("can not open %s!\n", imu_path.c_str());
    return -1;
  } else {
    PCM_PRINT_INFO("open imu file: %s\n", imu_path.c_str());
  }

  // check the img paths
  std::stringstream img_ss(par.get<std::string>("img_paths"));
  std::string tmp_path;
  std::vector<std::string> img_paths;
  std::vector<ImgNameChecker::BinNameEle> bin_eles;
  while (std::getline(img_ss, tmp_path, ',')) {
    ImgNameChecker::BinNameEle ele;
    ImgNameChecker::GetImgBinNameEle(tmp_path, &ele);
    if (ele.tail != "bin") {
      PCM_STREAM_ERROR(tmp_path << ": wrong extension name!" << std::endl);
      return -1;
    }
    if (ele.pre != "cam_ch") {
      PCM_STREAM_ERROR(tmp_path << ": wrong file name!" << std::endl);
      return -1;
    }
    bin_eles.push_back(ele);
    img_paths.push_back(tmp_path);
  }

  // img decoders
  std::vector<ImgDecoder::Ptr> img_decoders;
  for (auto p : img_paths) {
    ImgDecoder::Ptr d = std::make_shared<ImgDecoder>(p);
    img_decoders.push_back(d);
    if (!d->OpenFile()) {
      PCM_PRINT_ERROR("can not open %s!\n", p.c_str());
      return -1;
    } else {
      PCM_PRINT_INFO("open img file: %s\n", p.c_str());
    }
  }

  ros::init(argc, argv,
            "rosbag_creater_node_" + utility_tool::GetCurLocalTimeStr());
  ros::NodeHandle nh("~");
  rosbag::Bag ros_bag;
  std::string ros_bag_name = par.get<std::string>("rosbag_name");
  ros_bag.open(ros_bag_name, rosbag::bagmode::Write);

  while (ros::ok()) {
    ImuReader::ImuData imu;
    imu_reader.ReadOneLine(&imu);
    sensor_msgs::Imu imu_msg;
    imu_msg.header.stamp = Tp2RosT(imu.timestamp_);
    imu_msg.header.frame_id = "body";
    imu_msg.angular_velocity.x = imu.gyr_x_;
    imu_msg.angular_velocity.y = imu.gyr_y_;
    imu_msg.angular_velocity.z = imu.gyr_z_;
    imu_msg.linear_acceleration.x = imu.acc_x_;
    imu_msg.linear_acceleration.y = imu.acc_y_;
    imu_msg.linear_acceleration.z = imu.acc_z_;

    ros_bag.write("/imu0", imu_msg.header.stamp, imu_msg);
    if (!imu_reader.JumpLine(1)) {
      PCM_PRINT_INFO("end of write imu!\n");
      break;
    }
  }

  const int img_step = par.get<int>("img_step");
  const int img_num = par.get<int>("img_num");
  for (size_t i = 0; i < img_decoders.size(); ++i) {
    int img_cnt = 0;
    while (ros::ok() && img_cnt++ < img_num) {
      ImgDecoder::Frame img_frame;
      img_decoders[i]->ReadOneFrame(&img_frame);

      std_msgs::Header raw_header = std_msgs::Header();
      raw_header.stamp = Tp2RosT(img_frame.timestamp_);
      raw_header.frame_id = "raw_cam_ch_" + bin_eles[i].ch;
      sensor_msgs::ImagePtr raw_img_msg =
          cv_bridge::CvImage(raw_header, "bgr8", img_frame.img_).toImageMsg();
      ros_bag.write("/" + raw_img_msg->header.frame_id,
                    raw_img_msg->header.stamp, raw_img_msg);

      // show
      cv::imshow("raw img", img_frame.img_);
      cv::waitKey(1);

      if (!img_decoders[i]->JumpFrame(img_step)) {
        PCM_PRINT_INFO("end of write ch %s!\n", bin_eles[i].ch.c_str());
        break;
      }
    }
  }

  ros_bag.close();

  return 0;
}
